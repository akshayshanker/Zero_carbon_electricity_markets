

"""
This module contains the HousingModel class and functions and operators 
requred to solve a HousingModel 
 
Classes: HousingModel 
         Class with parameters and function for the Housing Model

Functions: housingmodel_operator_factory
            Generates the operators require to solve an instance of Housing Model 
           
           housingmodel_function_factory
            Using a set of parameters, creates the primitive functions required
            to generate an instance of the HousingModel class

"""



# Import packages

import numpy as np

from quantecon import tauchen

import matplotlib.pyplot as plt
from itertools import product
from numba import njit, prange, jit

from sklearn.utils.extmath import cartesian 
from scipy.optimize import brute


from interpolation.splines import UCGrid, CGrid, nodes, eval_linear
import time
import pandas as pd
from pathos.pools import ProcessPool 
#from pathos.multiprocessing import Pool as ProcessPool
import copy



class HousingModel:

    """
    This class takes parameters and functions from a housing and asset 
    accumulation problem and creates a housing model class. 

    An instance of this class is a parameterized housing model with parameters, 
    functions, asset grids survival probabilities and shock processes. 

    The housing model 
    object can then be solved using operators generated by 
    housingmodel_operator_factory

    """


    def __init__(self,
                 functions,     # Dictionary containing functions of the model 
                 parameters,    # Dictionary containing parameters
                 survival,      # numpy array containing survival probabilities
                 V,             # Voluntary contribution grid (numpy array)
                 Pi,            # Risk share grid (numpy array)
                 ncores,
                ):

        
        # declare functions

        self.u, self.uc, self.uh                                = functions['u'], functions['uc'], functions['uh']
        self.b, self.b_prime                                    = functions['b'], functions['b_prime']
        self.y, self.DB_benefit                                 = functions['y'], functions['DB_benefit']
        self.adj_p, self.adj_v, self.adj_pi                     = functions['adj_p'], functions['adj_v'], functions['adj_pi']


        # declare parameters 

        self.beta, self.delta_housing                           = parameters['beta'], parameters['delta_housing']
        self.T, self.R, self.s, self.tzero                      = int(parameters['T']),parameters['R'], survival, parameters['tzero']
        self.tau_housing                                        = parameters['tau_housing']
        self.def_pi,self.sigma_plan                             = parameters['def_pi'], parameters['sigma_plan']
        self.phi_w, self.sigma_w                                = parameters['phi_w'], parameters['sigma_w']
        self.f_ACF, self.f_ASF, self.f_LSF, self.alpha          = parameters['f_ACF'], parameters['f_ASF'], parameters['f_LSF'], parameters['alpha']
        self.grid_size_A, self.grid_size_DC, self.grid_size_H   = parameters['grid_size_A'], parameters['grid_size_DC'], parameters['grid_size_H']
        self.v_S,self.v_E                                       = parameters['v_S'], parameters['v_E']
        self.r, self.r_h, self.r_l                              = parameters['r'], parameters['r_h'], parameters['r_l']
        self.sigma_r_H, self.r_H                                = parameters['sigma_r_H'], parameters['r_H']
        self.h, self.l, self.sigma_d                            = parameters['h'], parameters['l'], parameters['sigma_d']
        self.sigma_DC_V, self.sigma_DB_V                        = parameters['sigma_DC_V'], parameters['sigma_DB_V']
        self.sigma_DC_pi, self.sigma_DB_pi                      = parameters['sigma_DC_pi'], parameters['sigma_DB_pi']

        self.rho_beta, self.rho_alpha                           = parameters['rho_beta'], parameters['rho_alpha']
        self.sigma_beta, self.sigma_alpha                       = parameters['sigma_beta'], parameters['sigma_alpha']
        self.beta_bar, self.alpha_bar                           = parameters['beta_bar'], parameters['alpha_bar']
        self.grid_size_alpha, self.grid_size_beta               = parameters['grid_size_alpha'], parameters['grid_size_beta']
        self.alpha_housing                                      = parameters['alpha_housing']




        # declare grid sizes 
        self.grid_size_A, self.grid_size_DC, \
        self.grid_size_H, self.grid_size_Q                    = int(parameters['grid_size_A']),\
                                                                int(parameters['grid_size_DC']), \
                                                                int(parameters['grid_size_H']), \
                                                                int(parameters['grid_size_Q'])

        self.grid_size_Q_s                                    =  int(parameters['grid_size_Q_s'])

        self.grid_size_DCR, self.grid_size_W                  = int(parameters['grid_size_DCR']),int(parameters['grid_size_W'])

        self.A_min, self.A_max_W, self.A_max_R, self.DC_min, self.DC_max       = parameters['A_min'], parameters['A_max_W'], parameters['A_max_R'], parameters['DC_min'], \
                                                                                    parameters['DC_max']
        self.H_min, self.H_max                                  = parameters['H_min'], parameters['H_max']

        self.Q_min, self.Q_max                                  = parameters['Q_min'], parameters['Q_max']



        # generate asset grids 
        # NOTE: asset grids are UCGrid objects 
        self.A_DC                       = np.linspace(self.DC_min, self.DC_max, self.grid_size_DC)
        self.H                          = np.linspace(self.H_min, self.H_max, self.grid_size_H)


        self.X_cont_R       = UCGrid((self.A_min, self.A_max_R, self.grid_size_A),\
                                (self.H_min, self.H_max, self.grid_size_H), \
                                 (self.Q_min, self.Q_max, self.grid_size_Q))           # Construct continuous state-space for retirees


        self.X_cont_W       = UCGrid((self.A_min, self.A_max_W, self.grid_size_A),\
                                (self.DC_min, self.DC_max, self.grid_size_DC),\
                                (self.H_min, self.H_max, self.grid_size_H),\
                                (self.Q_min, self.Q_max, self.grid_size_Q))           # Construct continuous state-space for workers


        self.X_R_contgp     = nodes(self.X_cont_R)                                       # Nodes for retiree continuous state-space
        self.X_W_contgp     = nodes(self.X_cont_W)                                       # Nodes for worker continuous state-space


        # generate array indicating plan type. DB is 0 and DC is 1
        self.DB             = np.array([0,1])   

        # generate grid for voluntary contribution and risk share   
        self.V, self.Pi     = V, Pi                                         

        #generate labor shock process 
        self.labour_mc                  = tauchen(self.phi_w, self.sigma_w, \
                                                    n = int(self.grid_size_W)) # Generate the labour income shock state-space and transition matrix
        self.E, self.P_E, self.P_stat   = self.labour_mc.state_values, \
                                             self.labour_mc.P, \
                                             self.labour_mc.stationary_distributions[0]  
        
        # create beta and alpha processes 
        self.beta_mc                                    = tauchen(self.rho_beta, \
                                                            self.sigma_beta, \
                                                            n = int(self.grid_size_beta)) 
        self.beta_hat, self.P_beta, self.beta_stat      = self.beta_mc.state_values, \
                                                             self.beta_mc.P, \
                                                             self.beta_mc.stationary_distributions[0] #beta_hat are values of ln beta_{t} - ln beta_\bar 

        self.alpha_mc                                   =      tauchen(self.rho_alpha, self.sigma_alpha, n = int(self.grid_size_alpha)) 
        self.alpha_hat, self.P_alpha, self.alpha_stat   =      self.alpha_mc.state_values, self.alpha_mc.P, self.alpha_mc.stationary_distributions[0] #alpha_hat are values of ln beta_{t} - ln beta_\bar 

        # After agents retire, they have the mean level of beta and alpha
        # this overrides the alpha and beta from the parameters file
        # assumption can be dropped later 
        self.beta, self.alpha_housing        =      np.inner(np.exp(self.beta_hat + np.log(self.beta_bar)), self.beta_stat) ,\
                                                    np.inner(np.exp(self.alpha_hat + np.log(self.alpha_bar)), self.alpha_stat)



        # pension asset returns shock processes 

        lnrh_sd             =  self.sigma_d*(self.h**2)                             #OK for now, but triple check variance in the paper 
        self.lnrh_mc        =  tauchen(0, lnrh_sd, n = self.grid_size_DCR)          #OK for now, but triple check variance in the paper 
        X_rh, P_rh          =  self.lnrh_mc.state_values, self.lnrh_mc.P[0]
        self.X_rh,self.P_rh =  np.exp(np.log(self.r_h) + X_rh), P_rh

        lnrl_sd             =  self.sigma_d*(self.l**2)
        self.lnrl_mc        =  tauchen(0, lnrl_sd, n = self.grid_size_DCR) 
        X_rl, P_rl          =  self.lnrl_mc.state_values, self.lnrl_mc.P[0]         # Triple check that this is valid
        self.X_rl,self.P_rl =  np.exp(np.log(self.r_l) + X_rl), P_rl

        # Construct cartesian grid of realisatons from high and low risk asset 

        self.X_r            =  cartesian([self.X_rl, self.X_rh])                    
        P_tmp               =  cartesian([self.P_rl, self.P_rh])    
        
        # Construct joint probability array of high/low return realisations 
        self.P_r            =  np.zeros(len(self.X_r))                              
        for i in range(len(self.P_r)):
            self.P_r[i]     = P_tmp[i][0]*P_tmp[i][1]
        
        # housing return shocks 

        self.Q_shocks_mc                 = tauchen(0, self.sigma_r_H, n = self.grid_size_Q_s)
        self.Q_shocks_r, self.Q_shocks_P = self.Q_shocks_mc.state_values, self.Q_shocks_mc.P[0]

        # combine housing and pension return shocks 
        # Q_DC_shocks[0] gives safe asset shock, Q_DC_shocks[1]
        # gives risky asset shock and Q_DC_shocks[2] gives housing shock 

        self.Q_DC_shocks       = cartesian([self.X_rl, self.X_rh, self.Q_shocks_r])
        P_tmp2                 = cartesian([self.P_rl, self.P_rh, self.Q_shocks_P ])

        self.Q_DC_P            =  np.zeros(len(self.Q_DC_shocks))                              
        
        for i in range(len(self.Q_DC_P)):
            self.Q_DC_P[i]     = P_tmp2[i][0]*P_tmp2[i][1]*P_tmp2[i][2]
                                       

#        for t in range(len(self.P_h)-1):
 #           self.P_h[t+1]       = (1+self.r_H)*self.P_h[t]/ (1-self.delta_housing)     

        # Construct state-spaces 
        self.X_disc         = cartesian([np.arange(len(self.E)),\
                                np.arange(len(self.alpha_hat)),
                                np.arange(len(self.beta_hat)),
                                np.arange(len(self.V)),\
                                np.arange(len(self.Pi))])                              
        
                                                                                       # state index 0: labour shock, 1: alpha value, 2: beta value, 3, vol cont, 4, pi value     

        # Construct discrete state-space of exogenous states (non-choice)(only for workers) 
        self.X_disc_exog    = cartesian([np.arange(len(self.E)),\
                                np.arange(len(self.alpha_hat)),
                                np.arange(len(self.beta_hat))])                           
                                                                       

        self.X_disc_vals    = cartesian([self.E, self.alpha_hat, self.beta_hat, self.V, self.Pi])
        
        self.E_index, self.V_index, self.Pi_index = np.arange(len(self.E)),np.arange(len(self.V)), np.arange(len(self.Pi))

        # Initial value for the terminal period value function
        self.EVX_int        = np.ones(len(self.X_R_contgp))                                                     

        #self.ncores         = ncores


def housingmodel_operator_factory(og, parallel_flag=True):
    
    """A function that creates the operators required to Bellman iteration  

    Parameters
    ----------
    og : HousingModel 
         Instance of housing model class

    Returns
    -------
    gen_EVX: function 
        operator that conditions t+1 value function on t discrete states 

    bellman_operator: function
        Bellman operator 

    a_prime_func: function
        Function that returns t+1 liquid assets given time t assets 
    """

    u, uc, uh                                               = og.u, og.uc, og.uh 
    b, b_prime                                              = og.b, og.b_prime 
    y, DB_benefit                                           = og.y, og.DB_benefit
    adj_p, adj_v,adj_pi                                     = og.adj_p, og.adj_v, og.adj_pi


    beta,   delta_housing, alpha                            = og.beta, og.delta_housing, og.alpha
    tau_housing, def_pi                                     = og.tau_housing, og.def_pi     
    v_S,    v_E                                             = og.v_S,og.v_E 
    r,s, r_H                                                = og.r, og.s, og.r_H     
    alpha_housing                                           = og.alpha_housing

    Q_shocks_r, Q_shocks_P                                  = og.Q_shocks_r, og.Q_shocks_P
    Q_DC_shocks, Q_DC_P                                     = og.Q_DC_shocks, og.Q_DC_P 

    beta_hat, P_beta, beta_stat                             = og.beta_hat, og.P_beta, og.beta_stat 
    alpha_hat, P_alpha, alpha_stat                          = og.alpha_hat, og.P_alpha, og.alpha_stat 
    beta_bar, alpha_bar                                     = og.beta_bar, og.alpha_bar


    sigma_DC_V, sigma_DB_V                                  = og.sigma_DC_V, og.sigma_DB_V  
    sigma_DC_pi, sigma_DB_pi                                = og.sigma_DC_pi, og.sigma_DB_pi

    E, P_E, P_stat                                          = og.E, og.P_E, og.P_stat
    A_DC                                                    = og.A_DC
    H                                                       = og.H  
    A_min                                                   = og.A_min

    V, Pi                                                   = og.V, og.Pi
    X_r, P_r                                                = og.X_r, og.P_r
    X_disc, X_disc_vals, X_disc_exog                        = og.X_disc, og.X_disc_vals, og.X_disc_exog
    X_cont_W, X_cont_R                                      = og.X_cont_W, og.X_cont_R 
    X_W_contgp, X_R_contgp                                  = og.X_W_contgp, og.X_R_contgp 
    E_index, V_index, Pi_index                              = og.E_index, og.V_index, og.Pi_index                                  

    grid_size_A, grid_size_DC, grid_size_H                  = og.grid_size_A, og.grid_size_DC, og.grid_size_H
    T, tzero, R                                             = og.T, og.tzero, og.R

    A_max_W, H_max                                           = og.A_max_W, og.H_max
    DC_max                                                  =og.DC_max
    Q_max =og.Q_max
    
    # create processing pools for conditonal expectations operator and bellman operator 
    p_cond2                                                 = ProcessPool()
    p                                      = ProcessPool()
    
   



    @njit
    def a_prime_func(c,                     # Current period consumption (C_{t}) choice
                              h,            # Current period housing (H_{t}) choice 
                              x_disc,       # Current discrete state. Set to 0 if t>R. This an index of the discrete cartesian grid  (np.arange(len(X_disc))) NOT the val. 
                              x_cont,       # Current continuous state. This is an index in the nodes grids generated from the continuous grid object 
                              t,            # Current age
                              account_type, # O for DB and 1 for DC
                              wage,         # wage received this period 
                              DB_payout,    # DB payout received this period (mostly 0)
                              ):

        """Time t+1 liquid assets 

        Parameters
        ----------
        c : float64
            The value of consumption at t
        h : float64
            The value of housing decided this period 
        x_disc: int
            Time t discrete state. Index of arange(len(X_disc))
        x_cont: int
            Time t continuous state index 
        t: int
            Age
        account_type: int
            0 for DB and 1 for DC
        wage: float
            labour income 
        DB_payout: float
            pay-out at t from DB balance 
        
        Returns
        -------
        float 
            value of t+1 liquid assets 
        """

        if t==R:
            # pull out the vals associated with the current state                                          
            x_cont_vals = X_W_contgp[x_cont]                

            # This gives a tuple of indices for each of the discrete state spaces! not individual state space values!
            x_disc_ind  = X_disc[x_disc]

            # This gives the discrete state values                     
            x_disc_vals = X_disc_vals[x_disc]               
            
            # Remember the indexing housing brought *in from the previous period* is x_disc_vals[2]
            # No depreciation of x_disc_vals[2]!!! Depreciation does enter into x_prime. 


            # value of \tau*\Chi_{housing invesmtnet made in current period}
            # At age R, the DC balance matters so we are using the worker continuous grid. House value is indexed at 2
            if h == x_cont_vals[2]:                        
                tau_star = 0
            
            else: 
                tau_star   = tau_housing

            # next liquid period assets 

            a_prime    =  (1+r)*x_cont_vals[0] - c - x_cont_vals[3]*(h -x_cont_vals[2])\
                            - tau_star*x_cont_vals[3]*h\
                            + x_cont_vals[1] + DB_payout*(1-account_type)

        if t>R:

        
            # Note that the retirement age is R so the final
            # period when next period consumption will be on
            # the worker grid is R (even thought they do not recieve wage at R, they receive dc pay and DB)
            
            # pull out the vals associated with the current state
            x_cont_vals= X_R_contgp[x_cont]       

            if h == x_cont_vals[1]:
                tau_star = 0
            else: 
                tau_star   = tau_housing

            a_prime    =  (1+r)*x_cont_vals[0] - c -x_cont_vals[2]*(h -x_cont_vals[1])\
                            - tau_star*x_cont_vals[2]*h

           # print(x_cont_vals)
           # print(x_cont_vals[2])


        if t<R:

            # pull out the vals associated with the current state.
            x_cont_vals  = X_W_contgp[x_cont]        
            
            # Remember the indexing housing brought *in from the previous period* is x_disc_vals[2]. 
            # No depreciation of x_disc_vals[2]!!! Depreciation does enter into x_prime. 

            x_disc_vals = X_disc_vals[x_disc]
            
                                                                            
            if h == x_cont_vals[2]:
                tau_star = 0

            else: 
                tau_star         = tau_housing

            # Next period liquid capital 

            a_prime         =   (1+r)*x_cont_vals[0] - c - x_cont_vals[3]*(h -x_cont_vals[2])\
                                - tau_star*x_cont_vals[3]*h\
                                + (1-x_disc_vals[3] -v_S -v_E)*wage                      

        return a_prime




    @njit
    def objective_R(c,                  
                              h,        
                              EXV_bar,  
                              x_disc,    
                              x_cont,   
                              t,        
                              account_type, 
                              wage,
                              DB_payout,
                              ):

        """Maximand on the RHS of the Bellman equation function:
        utiltiy + next period value for retirees  fA

        Parameters
        ----------
        c : float64
            The value of consumption at t
        h : float64
            The value of housing decided this period 
        EXV_bar: ndarray 
            Next period value function conditioned on today's
            discrete states and tomorrow's continuous states  
        x_disc: int
            Time t discrete state. Index of arange(len(X_disc))
        x_cont: int
            Time t continuous state index 
        t: int
            Age
        account_type: int
            0 for DB and 1 for DC
        wage: float
            labour income 
        DB_payout: float
            pay-out at t from DB balance 
        
        Returns
        -------
        float 
            value of RHS of Bellman equation at t
        """

        # pull out the continuous vals associated with the current state
        if t>R:
            x_cont_vals = X_R_contgp[x_cont]    
        else:
            # when we are at ritirement age, the current asset in the DC 
            # account matters, hence we need to pull out the continuous grid 
            # for the workers 
            x_cont_vals = X_W_contgp[x_cont]     


        a_prime         = a_prime_func(c,h, x_disc, x_cont, t, account_type,\
                                         wage,DB_payout)




        if a_prime>0 and c >0 and h>0:
                    # assets left over for bequest  (note for now i use the time t price for house sale)
            A_prime         = a_prime + (1-delta_housing)*h*x_cont_vals[2]              


            Q_prime       = x_cont_vals[2]*(1+r_H + Q_shocks_r)

            state_prime_R   =   np.column_stack((np.full(len(Q_prime),a_prime), \
                                            np.full(len(Q_prime),(1-delta_housing)*h), \
                                            Q_prime))




            V_prime         = eval_linear(X_cont_R, EXV_bar, state_prime_R)

            return  u(c,h, alpha_housing) + s[t]*beta*np.dot(V_prime, Q_shocks_P) \
                        + (1-s[t])*beta*b(A_prime)
        else:
            return -np.inf

    @njit
    def objective_W(c,                  
                              h,        
                              EXV_bar,  
                              x_disc,   
                              x_cont,   
                              t,        
                              account_type, 
                              wage,
                              DB_payout,
                              ):

        """Maximand on the RHS of the Bellman equation function:
        utiltiy + next period value for workers

        Parameters
        ----------
        c : float64
            The value of consumption at t
        h : float64
            The value of housing decided this period 
        EXV_bar: ndarray 
            Next period value function conditioned on today's
            discrete states and tomorrow's continuous states  
        x_disc: int
            Time t discrete state. Index of arange(len(X_disc))
        x_cont: int
            Time t continuous state index 
        t: int
            Age
        account_type: int
            0 for DB and 1 for DC
        wage: float
            labour income 
        DB_payout: float
            pay-out at t from DB balance 
        
        Returns
        -------
        float 
            value of RHS of Bellman equation at t
        """


        # pull out the vals associated with the current state 
        x_cont_vals     = X_W_contgp[x_cont]    

        # this gives a tuple of indices for each of the discrete state spaces!
        x_disc_ind      = X_disc[x_disc]    

        # pull out the discrete state values                                    
        x_disc_vals     = X_disc_vals[x_disc]

        #pull out the values of beta and alpha 

        #pull out the values of beta and alpha 
        beta_t          = np.exp(x_disc_vals[2] + np.log(beta_bar))
        alpha_t  = np.exp(x_disc_vals[1] + np.log(alpha_bar))

        #calculate the next period liquid assets 
        a_prime         =  a_prime_func(c,h, x_disc, x_cont, t, \
                             account_type, wage,DB_payout)                

        # next period bequest assets 
        A_prime         = a_prime + (1-delta_housing)*h*x_cont_vals[3]          

        # next peroid housing 
        H_prime         = (1-delta_housing)*h                              

        # next period DC balance for DB 
        if account_type == 0:                                              # Triple check that I have the low and high risk return the right way around
          A_DC_prime   = (1+ (1-x_disc_vals[4])*Q_DC_shocks[:,0] \
                            + x_disc_vals[4]*Q_DC_shocks[:,1]) \
                            *(x_cont_vals[1] + ((1-alpha)*v_E \
                            + x_disc_vals[3])*wage)

        # next period DC balance for DC members 
        # probabilities in P_r are in the same order as thier states in A_DC_Prime

        if account_type == 1:
          A_DC_prime   = (1+(1-x_disc_vals[4])*Q_DC_shocks[:,0]\
                            + x_disc_vals[4]*Q_DC_shocks[:,1] )*(x_cont_vals[1] \
                            + (v_S + v_E+ x_disc_vals[3])*wage)            

        # next period possible values for the house price 

        Q_prime       = x_cont_vals[3]*(1+r_H + Q_DC_shocks[:,2])

        #Q_prime[Q_prime> Q_max] = Q_max


        # make sure suepr contributions do not go beyond grid 

        #A_DC_prime[A_DC_prime>A_DC_prime] = DC_max

        
        # Construct next period possible continuous state, one for each realisation of the DC*housing assett shock 


                            
        # now get the possible next period values, conditioned on:
        #   - next period DC balance
        #   - this period discrete state:
        #       a. labour shock
        #       b. alpha beta shock
        #       c. this period continuous states
        #
        #  NOTE: the EXV_bar values have conditioned over the next period 
        # random choices 

        state_prime_W = np.column_stack((np.full(len(Q_prime),a_prime), \
                A_DC_prime, \
                np.full(len(Q_prime),H_prime), \
                Q_prime))

        V_prime = eval_linear(X_cont_W, \
                    EXV_bar, \
                    state_prime_W)     



        if a_prime>0 and c >0 and h>0 and a_prime<=A_max_W and h<=H_max:


            return  u(c,h, alpha_t) + s[t]*beta_t*np.dot(V_prime,Q_DC_P) + (1-s[t])*beta_t*b(A_prime)

        else:
            return -np.inf





    def gen_EVX(V_bar,          
                t,              
                account_type):  # account type 
        
        
        """Takes in value function conditioned on discrete  choices for
         age t+1 and gives value function conditoned on assets 
         (A, DC, H) tomorrow and wage shock today

        Parameters
        ----------
        t: int
            Age of agent. Note this is age of the Value function being conditioned, NOT the age at which the bellman operator is being evaluated!
                            # should this be noted as t+1 for clarity?
        V_bar: numpy array
            t+1 value function conditioned on t+1 discrete choices 

        Returns
        -------
        EXV_bar
            t+1 Value function conditioned on continuous state and labour shock
            this is an interopant for equation (21)
        """
       
        # if agent is retired, then there are no shocks and discrete choices 


        if t> R:
       
            EXV_bar         = [V_bar]
            PC_v = 0
            PC_pi = 0

        if t <= R:                                    
            X_discrete_list = X_disc
            X_cont_list     = X_W_contgp


            # pull put adjustment costs for DB and DC 
            if account_type == 0:
              scaling_pi   = sigma_DB_pi
              scaling_v    = sigma_DB_V

            if account_type == 1:
              scaling_pi   = sigma_DC_pi
              scaling_v    = sigma_DC_V
                      

            @np.vectorize
            def exp_lb(x):
                return np.max([np.exp(x), 1e-200])


            def conditioning( 
                            x_cont_ind):
               

                # for given continuous index, produce list of possible next period discerete states 

                state_prime                 = cartesian([[x_cont_ind],np.arange(len(X_disc))])

                state_prime_disc_vals       = X_disc[list(state_prime[:,1].astype(int)),:] 

                # Make a seperate array for the index of next period discrete state 
                # (we do this so we can map to next period values easily by picking the 
                #  next period value function)     
                state_prime_disc_indx       = state_prime[:,1]                                              
                state_prime                 = state_prime[:,0]              

                # Now we have an array where the first col. is the unique next period cont value
                # and the subsequence cols are combintions of discrete states                               
                state_prime                 = np.column_stack([state_prime, state_prime_disc_vals])         

                # evaluate next period value function - adjustment cost for risk share adjustment (eq 19) 
                V_prime                     = V_bar[list(state_prime_disc_indx),x_cont_ind] \
                                                -adj_pi(t, X_W_contgp[x_cont_ind][1], adj_p(tzero))\
                                                *np.where(Pi[list(state_prime[:,5].astype(int))]!=def_pi, 1,0)           
                

                # the below steps make sure exponent of alue functions do not exceed machine prec.

                V_prime_super_threshold                 = V_prime> 5.93476553e+2*np.min([scaling_pi, scaling_v])                         
                V_prime[list(V_prime_super_threshold)]  = 5.93476553e+2*np.min([scaling_pi, scaling_v])                                                
                V_prime_supra_threshold                 = V_prime< -7.075322e+2
                V_prime[list(V_prime_supra_threshold)]  = -7.075322e+2

                state_prime_df          = pd.DataFrame(np.column_stack([state_prime, V_prime]))

                # take the value for next period and scale 

                state_prime_df[6]       = exp_lb(state_prime_df[6]/scaling_pi)

                # evaluate inside braces RHS of eq (22)
                state_prime_df_v        = state_prime_df.groupby([0,1,2,3,4], as_index=False)\
                                            .sum()\
                                            .reset_index()

                # evaluate denominato of eq (24). This step adds the denominator as a col with index 7
                probability_pi          = copy.copy(state_prime_df)
                probability_pi[7]       = state_prime_df.groupby([0,1,2,3,4])\
                                            .transform('sum')[6]
                                                                  
                # now evaluate equation (24)
                probability_pi[6]       = probability_pi[6]/probability_pi[7]       

                # evaluate equation 22 by  subtracting adjustment cost for making vol. cont. 
                state_prime_df_v[6]     =  scaling_pi*np.log(state_prime_df_v[6]) \
                                            - adj_v(t, X_W_contgp[x_cont_ind][0])\
                                            *np.where(V[list(state_prime_df_v[4].astype(int))]>0, 1,0)  
               
                state_prime_df_v[6]     =  exp_lb(state_prime_df_v[6]/scaling_v)

                probability_v           = copy.copy(state_prime_df_v)
                probability_v[7]        = state_prime_df_v.groupby([0,1,2,3])\
                                            .transform('sum')\
                                            .reset_index()[6]                          
                
                probability_v[6]        = probability_v[6]/probability_v[7]  

                # now evaluate RHS inside brackes of equation 21 
                state_prime_df_x        = state_prime_df_v.groupby([0,1,2,3], as_index=False)\
                                            .sum()\
                                            .reset_index()                          

                # evaluate RHS of 21 
                state_prime_df_x[6]     = scaling_v*np.log(state_prime_df_x[6])    
                                                                               

                # condition next period value function on today's labour, alpha and beta shocks
                EXV_tilda            = []

                # let disc_exog_ind be an index for all possible *exog* discrete states this weel (labour, alpha, beta)
                for disc_exog_ind in range(len(E)*len(beta_hat)*len(alpha_hat)):   

                    # the first line pulls out the probabilitiy of transitioning to each discrete state in list state_prime_dfx 
                    # tomorrow conditioned on state  disc_exog_ind today                                       
                    P_E_bar          = P_E[X_disc_exog[disc_exog_ind][0]][list(np.array(state_prime_df_x[1]).astype(int))]      
                    P_alpha_bar      = P_alpha[X_disc_exog[disc_exog_ind][1]][list(np.array(state_prime_df_x[2]).astype(int))]  
                    P_beta_bar       = P_beta[X_disc_exog[disc_exog_ind][2]][list(np.array(state_prime_df_x[3]).astype(int))]   

                    P_disc_bar       = P_E_bar*P_alpha_bar*P_beta_bar
                    EXV_tilda.append(np.inner(P_disc_bar, np.array(state_prime_df_x[6]))) 

                # EXV_tilda is now a list with the i'th element correspeding to the value function 
                # tomorrow conditoned on the ith shock today and x_cont_ind cont state tomrorow.
                

                # Return value function conditioned on t-1 labour shock and t continuous state 
                return [EXV_tilda, np.array(probability_v[[0,1,2,3,4,6]]), np.array(probability_pi[[0, 1,2, 3, 4,5,6]])]       

            # parrallelize the evaluation across all possible continuous states tomorrow 
            cond_res = np.array(p_cond2.map(conditioning,np.arange(len(X_cont_list))))

            # pull out the conditioned value function and discrete choice probabiltiies 
            EXV_bar  = []
            PC_pi    = []
            PC_v     = []
            for x_cont_ind in range(len(X_cont_list)):
                EXV_bar.append(cond_res[x_cont_ind][0])
                PC_v.append(cond_res[x_cont_ind][1])
                PC_pi.append(cond_res[x_cont_ind][2])
            
               

        return np.array(EXV_bar), np.array(PC_v), np.array(PC_pi)


    def bellman_operator(t, EVX_bar, account_type):
        """Takes in value function for time t+1 and gives policy and valufunction for time t

        Parameters
        ----------
        time: int
            Age of agent 
        EVX_bar: numpy array
            t+1 value function, conditioned on continuous state and labour shock 

        Returns
        -------
        V_sol
            age t value function, unconditioned  
        rho_c 
            age t consumption policy function 
        rho_h 
            age t housing policy functiin 
        """

       

        if t> R:

            X_discrete_list     = np.array([0])
            X_cont_list         = X_R_contgp

        if t<=R:
            X_discrete_list     = X_disc
            X_cont_list         = X_W_contgp

        X_all_list              = cartesian([np.arange(len(X_discrete_list)),np.arange(len(X_cont_list))])
        
        def solve_vfunc(state_ind):
            state               = X_all_list[state_ind]
            x_cont_vals         = X_cont_list[state[1]]

            if t>R:
                h0              = x_cont_vals[1]
                wage            = 0             
                P_h             = x_cont_vals[2]                                      # Initial housing guess is to stay put 
            else:
                h0              = x_cont_vals[2]
                P_h             = x_cont_vals[3] 

            if t== R:
                DB_payout       = DB_benefit(t, t-tzero, y(t,X_disc_vals[state[0]][0]), X_disc[state[0]][0], P_E,P_stat,E)
            else:
                DB_payout       = 0

            if t< R:
                EXV_bar_disc    = copy.copy(EVX_bar[int(X_disc[state[0]][0])])
                wage            = y(t,X_disc_vals[state[0]][0])
                objective       = objective_W

            else:
                EXV_bar_disc    =  np.array(EVX_bar)
                wage            =  0
                objective       =  objective_R

            c_max   = a_prime_func(0, 0, state[0],state[1], t, account_type, wage,DB_payout) 
            c_max_0 = a_prime_func(0, h0, state[0],state[1], t, account_type, wage,DB_payout)               #max c possible if h0 is constrainted to no investment adjustment 
            
            #@njit
            maximand = lambda x:   -objective(x[0],     # Current period consumption (C_{t}) choice
                                          x[1],         # Current period housing (H_{t}) choice 
                                          EXV_bar_disc, # Next period value function (V_{t+1})# do not confuse with voluntary contribution gr
                                          state[0],     # Current discrete state. Set to 0 if t>R. This an index of the discrete cartesian grid NOT (np.arange(len(X_disc))) the val. 
                                          state[1],     # Current continuous state. This is an index in the nodes grids generated from the continuous grid obect 
                                          t,            # Current age
                                          account_type, #  O for DB and 1 for DC
                                          wage,         #  wage for the time and disc. state
                                          DB_payout,
                                          )

            #use optimisation below for search across the space of no housing adjustment 
            x_bar   = [brute(maximand, ranges = ((0, c_max_0),(h0,h0)), Ns = 15, finish = 'Newton'), \
                       brute(maximand, ranges = ((0, c_max),(0,c_max/P_h)), Ns= 15 , finish = 'Newton')]   

            #x_bar[0] is the maximised value with no adjustment, x_bar[1] is the maximised value witha adjustment allowed
    
            x       =  x_bar[np.argmin([maximand(x_bar[0]), maximand(x_bar[1])])]

            a_prime_val = a_prime_func(x[0], x[1], state[0],state[1], t, account_type, wage,DB_payout) 
            return [np.max([-maximand(x),1e-200]), x[0], x[1],a_prime_val,x[1] - h0]

        ray_res         = np.array(p.map(solve_vfunc, np.arange(len(X_all_list))))

        V_sol           = ray_res[:,0].reshape(len(X_discrete_list), len(X_cont_list))     
        rho_c_sol       = ray_res[:,1].reshape(len(X_discrete_list), len(X_cont_list))    
        rho_h_sol       = ray_res[:,2].reshape(len(X_discrete_list), len(X_cont_list))    
        a_prime_vals    = ray_res[:,3].reshape(len(X_discrete_list), len(X_cont_list))    
        h_inv           = ray_res[:,4].reshape(len(X_discrete_list), len(X_cont_list))    

        return V_sol, rho_c_sol,rho_h_sol, a_prime_vals, h_inv



    return gen_EVX, bellman_operator, a_prime_func



def housingmodel_function_factory(parameters, 
                                    lambdas, 
                                    normalisation):   

    #alpha_housing = parameters['alpha_housing']
    gamma         = parameters['gamma']
    rho           = parameters['rho']
    gamma         = parameters['gamma']
    theta         = parameters['theta']
    k             = parameters['k']
    f_ACF         = parameters['f_ACF']         # Average contribution factor
    f_ASF         = parameters['f_ASF']         # Average service factor 
    f_LSF         = parameters['f_LSF']          # Lump sum factor 
    tzero         = parameters['tzero']

    # adjustment cost parameters 

    nu_v_0          =        parameters['nu_v_0']
    nu_v_1          =        parameters['nu_v_1']
    nu_v_2          =        parameters['nu_v_2']
    nu_v_3          =        parameters['nu_v_3']
    nu_p_0          =        parameters['nu_p_0']
    nu_p_1          =        parameters['nu_p_1']
    nu_p_2          =        parameters['nu_p_2']
    nu_r_0          =        parameters['nu_r_0']
    nu_r_1          =        parameters['nu_r_1']
    nu_r_2          =        parameters['nu_r_2']
    nu_r_3          =        parameters['nu_r_3']
    nu_r_4          =        parameters['nu_r_4']
    psi_adj         =        parameters['psi']

    @njit
    def u(c,h, alpha_housing):
        "The utility function"
        if c>0 and h>0:
            return ((-1+ np.power(((1-alpha_housing)*np.power(c,rho) + alpha_housing*np.power(h,rho)),((1-gamma)/rho)))\
                    /(1-gamma))/normalisation[0] 
        else:
            return -np.inf


    def uc(c,h):
        "Derivative of utility function wrt to consumption"
        return ((1-alpha_housing)*c**(rho-1))*((1-alpha_housing)*c**rho + alpha_housing*h**rho)**((1-gamma-rho)/rho)

    def uh(c,h):
        "Derivative of utility function wrt to housing"
        return (alpha_housing*h**(rho-1))*((1-alpha_housing)*c**rho + alpha_housing*h**rho)**((1-gamma-rho)/rho)

    @njit
    def b(A):

        "Bequest function"
        return (theta*(np.power(A+k,(1-gamma)))/(1-gamma))/normalisation[0] 

    def b_prime(A):
        "Derivative of bequest function"
        return  theta*((A+k)**(-gamma))

    def y(t,xi):
  
        tau = t - tzero 

        wage_age = np.inner(np.array([1, t, np.power(t,2), np.power(t,3), np.power(t,4)]), lambdas[0:5])
        wage_tenure = np.inner(np.array([tau, np.power(tau, 2)]), lambdas[5:8])

        return np.exp(wage_age + wage_tenure + xi)/normalisation[0] 

    def DB_benefit(t,                               # Age
               tau,                                 # Tenure 
               w,                                   # Current wage 
               Xi_index,                            # Current period shock index
               P,                                   # Probability matrix of income shocks 
               P_stat,                              # Stationary distribution 
               E,                                   # State space of income shocks 
               ):
        
        sum_1 = (1/P_stat[Xi_index])*np.sum(\
                        np.multiply(P_stat,P[:,Xi_index])*np.exp(\
                        np.inner(np.array([1, t, np.power(t-1,2), np.power(t-1,3), np.power(t-1,4)]), lambdas[0:5])\
                        + np.inner(np.array([tau-1, np.power(tau-1, 2)]), lambdas[5:8])
                        + E))

        sum_2 = (1/P_stat[Xi_index])*np.sum(\
                        np.multiply(P_stat,P[:,Xi_index])*np.exp(\
                        np.inner(np.array([1, t, np.power(t-2,2), np.power(t-2,3), np.power(t-2,4)]), lambdas[0:5])\
                        + np.inner(np.array([tau-2, np.power(tau-2, 2)]), lambdas[5:8])
                        + E))

        return f_ACF*f_ASF*f_LSF*tau*np.mean([w,sum_1, sum_2])/normalisation[0]

    #@njit
    def adj_p(t_zero):
        """Gives adjustment cost at tzero for plan switching
        """
        return (psi_adj + np.exp(nu_p_0 + nu_p_1*t_zero + nu_p_2*np.power(t_zero,2)))/normalisation[1]

    #@njit
    def adj_v(t, a):
        """Gives adjustment cost at tzero for voluntary cont switching
        """
        return (psi_adj + np.exp(nu_v_0 + nu_v_2*np.power((t - nu_v_1),2) + nu_v_3*np.max([0, np.log(a)])))/normalisation[1]

    #@njit
    def adj_pi(t, a_dc, adj_p):
        return (psi_adj + np.exp(nu_r_0 + nu_r_1*t + nu_r_2*np.power(t,2) + nu_r_3*np.max([0, np.log(a_dc)])) + nu_r_4*adj_p)/normalisation[1]

    return u, uc, uh, b, b_prime, y, DB_benefit, adj_p, adj_v, adj_pi



